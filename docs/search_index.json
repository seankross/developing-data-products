[
["index.html", "Developing Data Products Preface 0.1 About this book", " Developing Data Products Brian Caffo and Sean Kross 2016-12-13 Preface 0.1 About this book This book is written as a companion book to the Developing Data Products Coursera class as part of the Data Science Specialization. However, if you do not take the class, the book mostly stands on its own. A useful component of the book is a series of YouTube videos that comprise the Coursera class. The book is intended to be a low cost introduction to the important field of data products. The intended audience are students who are numerically and computationally literate, who would like to put those skills to use in Data Science. The book is offered for free as a series of R Markdown documents on Github and in more convenient forms (epub, mobi) on LeanPub. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License, which requires author attribution for derivative works, non-commercial use of derivative works and that changes are shared in the same way as the original work. "],
["introduction.html", "Introduction 0.2 What is a data product? 0.3 The goal of this book", " Introduction 0.2 What is a data product? We’ll begin this book by defining the topic of this class, data products. A data product is the production output of a data analysis. For example, a data analysis might build a clever machine learning algorithm. A data product embeds that algorithm in a web site so that users can input values and get predictions. Interactive analysis web sites, graphics, apps, R packages, presentations and reports are all data products. In this book we focus only on a few of these components. Mostly for space reasons, but also because our Coursera specialization covers others (like report writing). Before beginning this book, you should be able to use R. This language will serve as the launching point for all of our data products. Fortunately, if you don’t know R, Roger Peng has a great Coursera class and LeanPub book on the subject; take and read those first. The class runs every month and both can be obtained for free. Why R? Well for starters, it’s what I know. But, also it’s a very prevalent data analysis language. Thus, it’s convenient to build the data product in the same language as the analysis is done in. In addition, the list of tools that one needs to learn beyond R to develop data products is massive and include: HTML, Javascript, D3, Python, Amazon Web Services, and so on. In some sense, the tools we present are best thought of as prototyping tools before building a larger production endeavor. However, for many applications, they can stand alone. Shiny, in particular, is undergoing rapid adoption, development and growth. 0.3 The goal of this book This book (and the corresponding class) has one simple goal: get you started on making data products by introducing you to some very neat tools in R. We only scratch the surface on most of these fantastic platforms, and sadly omit some important ones. It’s best to pursue this book with a simple data project in mind. So, before begining, think of a data oriented web app that you’d like to create. Try using the tools in progress to create simplified versions of your app. Hopefully by the end you’ll have a large enough toolkit to be able to learn what you need to build your app or product. "],
["r-markdown.html", "Chapter 1 R Markdown 1.1 Introduction to Markdown 1.2 Basic Markdown Syntax 1.3 Putting the R in R Markdown 1.4 Writing and Rendering Documents 1.5 Creating Presentations in R Markdown 1.6 Sharing R Markdown Documents 1.7 Closing Thoughts", " Chapter 1 R Markdown Watch this video before beginning. 1.1 Introduction to Markdown Markdown is a lightweight markup language which emphasizes ease of writing and reading content and can easily be converted into HTML. Markdown was invented by John Gruber with significant contributions from Aaron Swartz. R Markdown extends markdown to include R code results including tables and visualizations. The rmarkdown package can create web pages, PDFs, and slide presentations from R Markdown documents. The real power of R Markdown is the ability to intertwine natural language and code. This approach is known as literate programming. 1.2 Basic Markdown Syntax Below are a few examples of Markdown’s syntax. You can find a comprehensive syntax guide on RStudio’s website. 1.2.0.1 Headers # I&#39;m huge! ## I&#39;m still large ### I&#39;m a reasonable size 1.2.0.2 Prose It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way – in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only. 1.2.0.3 Bold and italic *italic* **bold** ***bold and italic*** 1.2.0.4 Lists Unordered: - an item - another item - a third item Ordered: 1. an item 2. another item 3. a third item 1.2.0.5 Links [JHU&#39;s Homepage](http://www.jhu.edu) 1.2.0.6 Images ![A seagull](https://farm9.staticflickr.com/8221/8259009216_4b4e6f994c_m.jpg) 1.2.0.7 Quoted Text &gt; Good night, Mrs. Calabash, wherever you are. 1.2.0.8 Code # Code from Hadley Wickham&#39;s purr package reduce &lt;- function(.x, .f, ..., .init) { .f &lt;- as_function(.f, ...) f &lt;- function(x, y) { .f(x, y, ...) } Reduce(f, .x, init = .init) } 1.2.0.9 Inline Code You can use the `c()` function to make vectors. 1.3 Putting the R in R Markdown If you want to insert R code into an R Markdown document you can use the following syntax: ```{r} # Write some R code here! x &lt;- rnorm(10) x^2 plot(x) ``` The results of computing x^2 and the graph produced by plot(x) will both be displayed under this chunk of R code once you render this R Markdown file into a web page, a PDF, or a presentation. There are several options that are useful for customizing these R code chunks which we’ll discuss in a later section. 1.4 Writing and Rendering Documents Open up a new file in a plain text editor and have your R console ready. I highly recommend using RStudio since it nicely combines a plain text editor, an R console, and a file browser. Write some markdown in your plain text editor, or copy and paste the R Markdown below: --- title: &quot;Simulation in R&quot; author: Brian Caffo date: July 28, 2016 --- ## Simple Simulation in R Welcome to my tutorial on doing very simple simulations in R. The first simulation we&#39;re going to try is flipping a coin, which can result in the the coin landing heads up or tails up. We can simulate flipping one coin by running the `flip_one_coin()` function defined below: ```{r} flip_one_coin &lt;- function(){ sample(c(&quot;H&quot;, &quot;T&quot;), 1) } ``` ## Simulation 1 Let&#39;s test the simple result of performing one coin flip: ```{r} flip_one_coin() ``` ## Flip Many Coins Instead of flipping one coin at a time, we can define a function that will flip a specified number of coins: ```{r} flip_coins &lt;- function(n){ sample(c(&quot;H&quot;, &quot;T&quot;), n, replace = TRUE) } ``` ## Coin Filling Results Let&#39;s take a look at the results of flipping 100 coins with a bar graph: ```{r} barplot(table(flip_coins(100))) ``` One feature of R Markdown that is different from regular Markdown is the presence of yaml front matter at the beginning of the file. Yaml is a simple medium for providing metadata about the document that you’re writing. The yaml front matter is written in-between a pair of three hyphens (---) at the beginning of the document. In the Rmd file above I’ve specified a title, author, and date for this document which will be placed at the beginning of the document. Save your R Markdown document in your current working directory as simple_sim.Rmd. In order to render this document into a webpage first install the rmarkdown package if you haven’t already with install.packages(&quot;ramrkdown&quot;). Once the package is installed you can load the rmarkdown package with library(rmarkdown). You can then render your R Mardown into a webpage by entering render(&quot;simple_sim.Rmd&quot;) into the R console. After the HTML document has been produced you can view your new document by entering browseURL(&quot;simple_sim.html&quot;) into the R console. Congratulations on creating your first data product! If you want to create a PDF instead of an HTML document you need to provide different arguments to the render() function. Enter render(&quot;simple_sim.Rmd&quot;, output_format = pdf_document()) into the R console in order to create a PDF. There are several advantages and disadvantages between distributing HTML or PDF documents. HTML allows your data product to be distributed as a website which allows you to embed interactive visualizations, some of which will we talk about creating in a later chapter. PDF documents are more self-contained compared to HTML, although they are static documents - they’re not responsive like a webpage can be. In general, if you want others to build upon your data product 1.5 Creating Presentations in R Markdown In addition to creating webpages and PDFs from R Markdown, you can also create slide presentations. Use the R Markdown document from the previous section and enter render(&quot;simple_sim.Rmd&quot;, output_format = ioslides_presentation()) into the R console. Now open up the slide deck with browseURL(&quot;simple_sim.html&quot;). As you can see this is still a webpage, except your document has been rendered as a slide deck! Each slide is demarcated in your R markdown file with two pound signs ## followed by the title of the slide. The fields specified in the yaml front matter create the first slide. If you’d rather produce PDF slides, you can enter render(&quot;simple_sim.Rmd&quot;, output_format = beamer_presentation()) into the R console in order to create PDF slides with the LaTeX Beamer framework. 1.6 Sharing R Markdown Documents We recommend the following websites for sharing the HTML files that you produce from R Markdown documents. If you’ve taken The Data Scientist’s Toolbox then you should be familiar with GitHub Pages. If you’re familiar with Git and you haven’t used it before their documentation for creating a site is very straightforward. If you’re not familiar with Git and you’re using RStudio you should take advantage of RPubs, which is perhaps the easiest way to share an HTML document from RStudio. You can find simple instructions for using RPubs here. If you’re looking for a site that will host any HTML file for free, including HTML files that are generated by R Markdown, you should check out NeoCities. 1.7 Closing Thoughts With R Markdown you can intertwine code from many programming languages, including R, with prose, tables, and graphics. From the source of one Rmd file you can produce several different kinds of data products including websites, PDFs, and even ebooks. For more information about R Markdown we encourage you to visit http://rmarkdown.rstudio.com/. "],
["shiny.html", "Chapter 2 Shiny 2.1 Installing Shiny 2.2 Your First Shiny App 2.3 More UI Elements 2.4 Inputs and Outputs 2.5 Dynamic UI 2.6 Reactivity 2.7 Interactivity 2.8 Sharing Apps 2.9 Conclusion 2.10 Style and markup 2.11 Different input types 2.12 Making your site interactive 2.13 Putting it all together 2.14 Another example 2.15 Sharing your app 2.16 talk about shiny server later", " Chapter 2 Shiny Watch this video before beginning Shiny is a modern programming miracle and it helps to make R one of the most competitive languages for communicating insights from data. Shiny is developed by RStudio and it is described as “A web application framework for R”. Unlike web application frameworks in many other languages the time it takes to write a beautiful, functional, and mobile-ready Shiny application is truly minimal, which makes it ideal for rapid prototyping and easy deployment. The folks at RStudio have the following pitch: “Turn your analyses into interactive web applications No HTML, CSS, or JavaScript knowledge required”. This statement is mostly true, though a little HTML knowledge is useful for understanding some of the concepts. If you’re interested in learning more about HTML, CSS, and Javascript we recommend any one of the following resources: Mozilla Developer Network Tutorials HTML &amp; CSS from Khan Academy Tutorials from Free Code Camp We’ll proceed as if your HTML knowledge is very basic and no more advanced than understanding heading levels or fonts. 2.1 Installing Shiny First, make sure you have the latest release of R installed. If on Windows, make sure that you have Rtools installed. Then, you can install shiny with install.packages(&quot;shiny&quot;) libray(shiny) 2.2 Your First Shiny App Let’s build our first app. Like many projects in this book, we’ll start with a simple example app. First create a new directory where you can store all of the files associated with your app. I like to organize my shiny app into two separate files: ui.R which contains all of the user interface elements of the app, and server.R which contains the logic of the app, including code for loading and handling data. You can find the code for each of these files below: App 1: ui.R library(shiny) fluidPage( titlePanel(&quot;Data science FTW!&quot;), sidebarLayout( sidebarPanel( h3(&quot;Sidebar Text&quot;) ), mainPanel( h3(&quot;Main Panel Text&quot;) ) ) ) App 1: server.R library(shiny) function(input, output){ } This app is extremely minimal, it’s just meant to get you familair with the syntax of shiny apps including the nested nature of the user interface elements. Create these two files inside of your new directory, then change your current working directory to that folder using setwd(). After loading shiny with library(shiny) enter runApp() into the R console to start the app. Alternatively you can provide the path to the directory containing the ui.R and server.R files as an argument to runApp(). You app should look something like this: Your First Shiny App Let’s walk through the code in ui.R. The fluidPage() function specifies a type of user interface for Shiny to display. Fluid pages try to intelligently rearrange themselves depending on the size of the screen that’s displaying the app which makes this layout look better on mobile devices. Instead of a fluidPage() you could use a fixedPage() which will not resize your app. The titlePanel() function defines a title on the top of the page and the sidebarLayout() function defines the layout for everything below the title panel. The sidebarLayout() splits the page into a sidebar and a main part of the page, which are then specified with the sidebarPanel() function and the mainPanel() function respectively. Inside the sidebarPanel() and the mainPanel() I put an h3() heading, which just displays some text and is the same as specifying an &lt;h3&gt; tag in HTML. The ui.R simply defines the layout of the page. If you run the code in ui.R on it’s own you can see that a standard set of HTML tags are returned: &lt;div class=&quot;container-fluid&quot;&gt; &lt;h2&gt;Data science FTW!&lt;/h2&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;form class=&quot;well&quot;&gt; &lt;h3&gt;Sidebar Text&lt;/h3&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-8&quot;&gt; &lt;h3&gt;Main Panel Text&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; All Shiny is doing is piecing together some HTML! 2.3 More UI Elements Let’s take a look at another simple app with a slighly more complex UI: App 2: ui.R library(shiny) fluidPage( titlePanel(&quot;HTML Tags&quot;), sidebarLayout( sidebarPanel( h1(&quot;H1 Text&quot;), h3(&quot;H3 Text&quot;), em(&quot;Emphasized Text&quot;) ), mainPanel( h3(&quot;Main Panel Text&quot;), code(&quot;Some Code!&quot;) ) ) ) App 2: server.R library(shiny) function(input, output){ } The code above will produce an app like this: A Second Shiny App In this example we’ve added a few UI elements and you can see how they are rendered in the app. The h1() and h3() functions specify headers, the em() function italicizes text, and the code() function renders the text with a monospaced font to make it look like computer code. You can find a listing of all of the different UI text tags that are availible by typing ?builder into the R console. 2.4 Inputs and Outputs Now that you know the basics of the Shiny user interface you can start to learn how to make your Shiny apps do something useful! The most important feature of a web application is that a user can provide input through interacting with your app, and then you can show the user outputs that respond to those inputs. Let’s start with the following simple Shiny app: App 3: ui.R library(shiny) fluidPage( titlePanel(&quot;Slider App&quot;), sidebarLayout( sidebarPanel( h1(&quot;Move the Slider!&quot;), sliderInput(&quot;slider1&quot;, &quot;Slide Me!&quot;, 0, 100, 0) ), mainPanel( h3(&quot;Slider Value:&quot;), textOutput(&quot;text&quot;) ) ) ) App 3: server.R library(shiny) function(input, output){ output$text &lt;- renderText(input$slider1) } The code above will produce an app that looks like this: A Simple Slider A screenshot of this app doesn’t do it justice, make sure you run this app on your own computer! You can do this easily by entering the following into your R console: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app3/&quot;) Try sliding the slider back and forth. The number displayed on the page should change to reflect the value of the slider. In ui.R the only new function is sliderInput() which defines the slider user interface element on the page. This function takes several arguments including a unique identifier for this slider (&quot;slider1&quot; in this case), text to be displayed above the slider, and finally minimum, maximum, and inital values for the slider. The second new function in the UI is textOutput(). This function renders text that is computed in server.R. The only argument passed to this function is a string with the ID of the text which is specified in server.R. We’ll designate a simple ID called &quot;text&quot; which we’ll use later in server.R. This app is the first one I’ve showed that has something notable going on in server.R. The server.R file must return a function, so for simple apps it’s appropriate to define a anonymous function like we’ve done in this example. This function must have arguments named input and output. You should think of the values of these arguments inside of the server function as a list() which each have named elements that you can query (in the case of input) and assign values to (in the case of output). In this example we’re retrieving the value of the slider from input according to the identifier we assigned to it in ui.R (&quot;slider1&quot;). The expression input$slider1 evaluates to the current value of the slider. We then wrap that expression with the renderText() function which renders a value so it can be printed as text in a Shiny app. The rendered value is then stored in the output list in the text element. The app’s UI is then able to retrieve this value since we specified the text ID in ui.R, and the value of the slider is thus displayed on the screen. If you understand how the app describe above is working, then you understand basic input and output in Shiny! On the server side of a Shiny app, you’re often writing code that takes inputs from the UI, does some computation, and you must render the result of that computation in order to show it to the user. Usually you can accomplish this with the render family of functions included in Shiny. In the next app we’ll take a look at showing a plot to the user based on some inputs, eventually using the renderPlot() function. App 4: ui.R library(shiny) fluidPage( titlePanel(&quot;Plot Random Numbers&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;num_points&quot;, &quot;How Many Random Numbers Should be Plotted?&quot;, value = 1000, min = 1, max = 1000, step = 1), sliderInput(&quot;sliderX&quot;, &quot;Pick Minimum and Maximum X Values&quot;, -100, 100, value = c(-50, 50)), sliderInput(&quot;sliderY&quot;, &quot;Pick Minimum and Maximum Y Values&quot;, -100, 100, value = c(-50, 50)), checkboxInput(&quot;show_xlab&quot;, &quot;Show/Hide X Axis Label&quot;, value = TRUE), checkboxInput(&quot;show_ylab&quot;, &quot;Show/Hide Y Axis Label&quot;, value = TRUE), checkboxInput(&quot;show_title&quot;, &quot;Show/Hide Title&quot;) ), mainPanel( h3(&quot;Graph of Random Points&quot;), plotOutput(&quot;plot1&quot;) ) ) ) App 4: server.R library(shiny) function(input, output) { output$plot1 &lt;- renderPlot({ set.seed(2016-12-13) dataX &lt;- runif(input$num_points, input$sliderX[1], input$sliderX[2]) dataY &lt;- runif(input$num_points, input$sliderY[1], input$sliderY[2]) xlab &lt;- ifelse(input$show_xlab, &quot;X Axis&quot;, &quot;&quot;) ylab &lt;- ifelse(input$show_ylab, &quot;Y Axis&quot;, &quot;&quot;) main &lt;- ifelse(input$show_title, &quot;Title&quot;, &quot;&quot;) plot(dataX, dataY, xlab = xlab, ylab = ylab, main = main, xlim = c(-100, 100), ylim = c(-100, 100)) }) } The code above will produce an app that looks like this: Plot Random Points You can run the app locally with this line of code: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app4/&quot;) This app has more code than any of the apps we’ve built before, but it’s just an extension of the same ideas we’ve been talking about. In ui.R there are a few new functions. The numericInput() function allows users to type in a number into a text box. You’ve already seen the sliderInput() function, but in this case there are two inital values, which allows the user to select a range of values on a slider between a minimum and maximum value. Next there’s the checkboxInput() function which creates a checkbox on the page that the user can toggle. Finally the plotOutput() function displays a plot that is rendered in server.R. All of the action in this server.R file takes place within an expression passed to renderPlot() since a plot is the only output of this app. The number of random numbers to generate is retrieved from input$num_points and each slider returns a numeric vector of length two, with the first element as the leftmost slider value and the second element as the rightmost slider value. The axis title is toggled on and off by input$show_title which is TRUE if the checkbox is checked and FALSE otherwise. The same principle applies to the axis labels. Finally the plot is constructed with a regular plot() function using UI inputs as parameters. 2.5 Dynamic UI You might want to change how the user interface of your Shiny app is displayed depending on other UI inputs in your app. This is a common pattern seen in online forms, where your choice in an early part of a form narrows the potential choices in later parts of the form. Here’s a small app that illustrates how to dynamically change the UI in Shiny: App 5: ui.R library(shiny) fluidPage( titlePanel(&quot;Dynamic UI&quot;), sidebarLayout( sidebarPanel( selectInput(&quot;country&quot;, &quot;Which Country do you live in?&quot;, choices = c(&quot;USA&quot;, &quot;Canada&quot;)), uiOutput(&quot;region&quot;) ), mainPanel( textOutput(&quot;message&quot;) ) ) ) App 5: server.R library(shiny) library(minimap) function(input, output) { output$region &lt;- renderUI({ if(input$country == &quot;USA&quot;){ selectInput(&quot;state&quot;, &quot;Which state do you live in?&quot;, choices = usa_abb) } else { selectInput(&quot;pt&quot;, &quot;Which province or territory do you live in?&quot;, choices = canada_abb) } }) output$message &lt;- renderText({ if(input$country == &quot;USA&quot;){ paste0(&quot;You live in the USA in the state of &quot;, input$state, &quot;.&quot;) } else { paste0(&quot;You live in Canada in the province or territory of &quot;, input$pt, &quot;.&quot;) } }) } The code above will produce an app that looks like this: Choose a Region You can run this app locally like so: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app5/&quot;) The ui.R in this app contains elements we’ve seen before except for the uiOutput() function. This function displays UI which is computed inside of server.R! Inside of server.R take a look at the renderUI() function, which contains code you would normally see inside of ui.R. The if statement determines which selectInput() is displayed, either the states of the USA, or the provinces and territories of Canada. Dynamic manipulation the UI can be a powerful tool for controlling the use and flow of your app. 2.6 Reactivity App 6: ui.R library(shiny) fluidPage( titlePanel(&quot;Predict Horsepower from MPG&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;sliderMPG&quot;, &quot;What is the MPG of the car?&quot;, 10, 35, value = 20), checkboxInput(&quot;showModel1&quot;, &quot;Show/Hide Model 1&quot;, value = TRUE), checkboxInput(&quot;showModel2&quot;, &quot;Show/Hide Model 2&quot;, value = TRUE) ), mainPanel( plotOutput(&quot;plot1&quot;), h3(&quot;Predicted Horsepower from Model 1:&quot;), textOutput(&quot;pred1&quot;), h3(&quot;Predicted Horsepower from Model 2:&quot;), textOutput(&quot;pred2&quot;) ) ) ) App 6: server.R library(shiny) function(input, output) { # Create Spline mtcars$mpgsp &lt;- ifelse(mtcars$mpg - 20 &gt; 0, mtcars$mpg - 20, 0) # Fit Models model1 &lt;- lm(hp ~ mpg, data = mtcars) model2 &lt;- lm(hp ~ mpgsp + mpg, data = mtcars) model1pred &lt;- reactive({ mpgInput &lt;- input$sliderMPG predict(model1, newdata = data.frame(mpg = mpgInput)) }) model2pred &lt;- reactive({ mpgInput &lt;- input$sliderMPG predict(model2, newdata = data.frame(mpg = mpgInput, mpgsp = ifelse(mpgInput - 20 &gt; 0, mpgInput - 20, 0))) }) output$plot1 &lt;- renderPlot({ mpgInput &lt;- input$sliderMPG plot(mtcars$mpg, mtcars$hp, xlab = &quot;Miles Per Gallon&quot;, ylab = &quot;Horsepower&quot;, bty = &quot;n&quot;, pch = 16, xlim = c(10, 35), ylim = c(50, 350)) if(input$showModel1){ abline(model1, col = &quot;red&quot;, lwd = 2) } if(input$showModel2){ model2lines &lt;- predict(model2, newdata = data.frame( mpg = 10:35, mpgsp = ifelse(10:35 - 20 &gt; 0, 10:35 - 20, 0) )) lines(10:35, model2lines, col = &quot;blue&quot;, lwd = 2) } legend(25, 250, c(&quot;Model 1 Prediction&quot;, &quot;Model 2 Prediction&quot;), pch = 16, col = c(&quot;red&quot;, &quot;blue&quot;), bty = &quot;n&quot;, cex = 1.2) points(mpgInput, model1pred(), col = &quot;red&quot;, pch = 16, cex = 2) points(mpgInput, model2pred(), col = &quot;blue&quot;, pch = 16, cex = 2) }) output$pred1 &lt;- renderText({ model1pred() }) output$pred2 &lt;- renderText({ model2pred() }) } The code above will produce an app that looks like this: Modeling Cars Make sure to runs this app locally: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app6/&quot;) App 7: ui.R library(shiny) fluidPage( titlePanel(&quot;Predict Horsepower from MPG&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;sliderMPG&quot;, &quot;What is the MPG of the car?&quot;, 10, 35, value = 20), checkboxInput(&quot;showModel1&quot;, &quot;Show/Hide Model 1&quot;, value = TRUE), checkboxInput(&quot;showModel2&quot;, &quot;Show/Hide Model 2&quot;, value = TRUE), submitButton(&quot;Submit&quot;) ), mainPanel( plotOutput(&quot;plot1&quot;), h3(&quot;Predicted Horsepower from Model 1:&quot;), textOutput(&quot;pred1&quot;), h3(&quot;Predicted Horsepower from Model 2:&quot;), textOutput(&quot;pred2&quot;) ) ) ) The code above will produce an app that looks like this: Delayed Computation You can run this app locally like so: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app7/&quot;) 2.7 Interactivity App 8: ui.R library(shiny) fluidPage( titlePanel(&quot;Brush Points to Visualize Model&quot;), sidebarLayout( sidebarPanel( h3(&quot;Slope&quot;), textOutput(&quot;slopeOut&quot;), h3(&quot;Intercept&quot;), textOutput(&quot;intOut&quot;) ), mainPanel( plotOutput(&quot;plot1&quot;, brush = brushOpts( id = &quot;brush1&quot; )) ) ) ) App 8: server.R library(shiny) function(input, output) { model &lt;- reactive({ brushed_data &lt;- brushedPoints(trees, input$brush1, xvar = &quot;Girth&quot;, yvar = &quot;Volume&quot;) if(nrow(brushed_data) &lt; 2){ return(NULL) } lm(Volume ~ Girth, data = brushed_data) }) output$slopeOut &lt;- renderText({ if(is.null(model())){ &quot;No Model Found&quot; } else { model()[[1]][2] } }) output$intOut &lt;- renderText({ if(is.null(model())){ &quot;No Model Found&quot; } else { model()[[1]][1] } }) output$plot1 &lt;- renderPlot({ plot(trees$Girth, trees$Volume, xlab = &quot;Girth&quot;, ylab = &quot;Volume&quot;, main = &quot;Tree Measurements&quot;, cex = 1.5, pch = 16, bty = &quot;n&quot;) if(!is.null(model())){ abline(model(), col = &quot;blue&quot;, lwd = 2) } }) } The code above will produce an app that looks like this: Brushed Points You can run this app locally like so: shiny::runGitHub(&quot;seankross/developing-data-products&quot;, subdir = &quot;assets/shinyapps/app8/&quot;) 2.8 Sharing Apps 2.9 Conclusion If you’re like most R users when you first encounter shiny, you’re probably wondering “What is going on? Why is the syntaxt so strange?” To get used to programming shiny apps, you need to throw away a little of your thinking about R; it’s a different style of programming. Let’s parse through what’s going on with our two files to hopefully make things more clear. The ui.R function is controlling the interface. The function shinyUI is alerting R to that. The interior function, fluidPage is telling shinyUI what kind of page to create. In this case, it’s a page that can rearrange itself based on what you include in the UI, and it can rearrange itself so the app is easy to use on mobile screens. You specify all elements of the page using functions. In this case we want a title titlePanel(&quot;Data science FTW!&quot;). Then we want the sidebarPanel to contain certain elements. So, the sidebarPanel function then takes arguments (again functions) of its elements. The statement h3('Sidebar text') is saying that we want the text Siderbar text in the sidebar (since this function occurs within the function sidebarPanel) and we want it to be at the font size h3. If you know a little html, you’ll recognize h3 as the third heading level font size. Similar to the sidebarPanel function, the mainPanel function takes functional arguments for the main panel. Probably the most frequent syntaxt error for shiny is not putting commas in the right places of ui.R. Remember, the page elements are input as arguments, so they need commas like all arguments to R functions.arguments The server.R file is a little easier. The function shinyServer tells R that it’s dealing with a shiny server. The server function always take an argument of an anonymous function with arguments inputs and outputs. In this case, our function doesn’t do anything. 2.10 Style and markup Perhaps the easiest way to illustrate markup is through an example. While keeping the server.R file the same, change the ui.R file to the following: {lang=r,line-numbers=off} ~ shinyUI(pageWithSidebar( headerPanel(“Illustrating markup”), sidebarPanel( h1(‘Sidebar panel’), h1(‘H1 text’), h2(‘H2 Text’), h3(‘H3 Text’), h4(‘H4 Text’) ), mainPanel( h3(‘Main Panel text’), code(‘some code’), p(‘some ordinary text’) ) )) ~ This produces the output: Markup from shiny. 2.11 Different input types Shiny allows for many different input types. In the following example, we change ui.R to allow for a few different input types. After you get the hang of these, any new ones will be easy. We leave server.R as is, so our inputs don’t do anything. See below the numeric input, checkbox, and date input. {lang=r,line-numbers=off} ~ shinyUI(pageWithSidebar( headerPanel(“Illustrating inputs”), sidebarPanel( numericInput(‘id1’, ‘Numeric input, labeled id1’, 0, min = 0, max = 10, step = 1), checkboxGroupInput(“id2”, “Checkbox”, c(“Value 1” = “1”, “Value 2” = “2”, “Value 3” = “3”)), dateInput(“date”, “Date:”) ), mainPanel( ) )) ~ Run this to see the inputs. They’re also shown in the next image a few paragraphs below. Refer to this lesson on the shiny tutorial site for a complete list of inputs available. Once you get the hang of one or two of them, then the remainder will be easy. So, do the above example first and then move on to trying some of the others. Right now, nothing is done with our inputs. Let’s see if we can figure output how to at least get them into server.R. 2.12 Making your site interactive Now that we have a bit of a handle on creating a shiny user interface, let’s make server.R reactive to the inputs from ui.R. First, let’s adapt our previous simple ui.R file to illustrate. Take the last example, where we collected a numeric input, checkbox and a date, and replace the mainPanel function with below. {lang=r,line-numbers=off} mainPanel( h3(‘Illustrating outputs’), h4(‘You entered’), verbatimTextOutput(“oid1”), h4(‘You entered’), verbatimTextOutput(“oid2”), h4(‘You entered’), verbatimTextOutput(“odate”) ) Our goal is to have our sidebarPanel collect the inputs and our main panel display them. The variables oid1, oid2 and odate are all outcome variables that we define in our server.R function. Here it is: {lang=r,line-numbers=off} ~ shinyServer( function(input, output) { output\\(oid1 = renderPrint({input\\)id1}) output\\(oid2 = renderPrint({input\\)id2}) output\\(odate = renderPrint({input\\)date}) } ) ~ So, our function takes in input$id1 and prints out oid1. Note that id1 was the name given to our numeric input in our ui.R function. This is storred in input$id1. The label id2 was given to our checkbox data in ui.R and it’s value is storred in input$id2. Similarly, date was the label given to the input date and it is stored in input$date. It is important in server.R to break from how we think about R programs being executed linearly. Instead, think of the functions being executed reactively to changing input from the ui.R function. The renderPrint function take the reactive input and assigns it to the output variable. Note the peculiar syntax for renderPrint in the ({R Statements }). In this case, our server.R function is merely taking our inputed data and returning it right back. We named our output variables oid1, oid2 and odate, the same names used in ui.R. The renderPrint statement says that it is being sent back to ui.R for formatted display. Here’s an example of the running of the code: Example of input/output in Shiny. 2.13 Putting it all together Now let’s build our prediction algorithm. For the ui.R files, let’s try {lang=r,line-numbers=off} ~ shinyUI( pageWithSidebar( # Application title headerPanel(“Diabetes prediction”), sidebarPanel( numericInput(&#39;glucose&#39;, &#39;Glucose mg/dl&#39;, 90, min = 50, max = 200, step = 5), submitButton(&#39;Submit&#39;) ), mainPanel( h3(&#39;Results of prediction&#39;), h4(&#39;You entered&#39;), verbatimTextOutput(&quot;inputValue&quot;), h4(&#39;Which resulted in a prediction of &#39;), verbatimTextOutput(&quot;prediction&quot;) ) ) ) ~ So, we have a sidebar panel that takes in the glucose value. The submitButton puts a button that waits until the button is pressed to send values to sever.R. We’ll discuss more on submit buttons in the next chapter. The main panel shows the output. Notice that verbatimTextOutput is the function that is used to display the output of our server.R functions. Our server.R function is {lang=r,line-numbers=off} ~ diabetesRisk &lt;- function(glucose) glucose / 200 shinyServer( function(input, output) { output\\(inputValue &lt;- renderPrint({input\\)glucose}) output\\(prediction &lt;- renderPrint({diabetesRisk(input\\)glucose)}) } ) ~ Notice that our prediction function is defined outside of the shinyServer function. The shinyServer function takes in the input and repeats both the input glucose level and the outputted diabetes risk. The output of the function is show below Output of our diabetes risk assessment score. 2.14 Another example A great way to use shiny is to create interactive graphics. Let’s go through a simple example exactly like the one we did in the manipulate chapter. The benifit of using shiny over manipulate is the ability to share the app broadly as a web page. Here’s our ui.R function {lang=r,line-numbers=off} ~ shinyUI(pageWithSidebar( headerPanel(“Example plot”), sidebarPanel( sliderInput(‘mu’, ‘Guess at the mean’,value = 70, min = 62, max = 74, step = 0.05,) ), mainPanel( plotOutput(‘newHist’) ) )) ~ Notice that plotOutput is the function used for plotting our generated histogram. Let’s consider the server.R function. {lang=r,line-numbers=off} ~ library(UsingR) data(galton) shinyServer( function(input, output) { output\\(newHist &lt;- renderPlot({ hist(galton\\)child, xlab=‘child height’, col=‘lightblue’,main=‘Histogram’) mu &lt;- input\\(mu lines(c(mu, mu), c(0, 200),col=&quot;red&quot;,lwd=5) mse &lt;- mean((galton\\)child - mu)^2) text(63, 150, paste(“mu =”, mu)) text(63, 140, paste(“MSE =”, round(mse, 2))) }) } ) ~ This shows how we created a somewhat elaborate set of code in the renderPlot statement that generates the plot. Specifically note the line mu &lt;- input$mu. This is our slider value that we use to generate our horizontal line. The final output is shown below: Output of our interactive plotting example. 2.15 Sharing your app Now that we have a working app we’d like to share it with the world. You could simply post the code, and whatever data files are needed, then users could use runApp to see the application. However, it’s much nicer to have it display as a stand alone web application. This requires running a shiny server to host the app. Instead of creating and deploying our own shiny server, we’ll rely on RStudio’s service shinyapps.io. You can go to https://www.shinyapps.io/ where you will be shown how to create an account. After creating the account, you’ll be able to host your shiny apps there. Note, this is a freemium service, so that if you want to host a lot of apps, and have fancy bells and whistles, you’ll have to spring for the paid service (or host your own shiny server). After getting a login, you’ll have to do some basic installs. First, devtools. (This is an essential package for a variety of reasons.) So, do install.packages(&quot;devtools&quot;) at the R command prompt. This will allow you to install the shinyapps package directly from github with the command devtools::install_github('rstudio/shinyapps'). Next you have to run some code that you can copy from the shinyapps.io site. It looks like {lang=r,line-numbers=off} shinyapps::setAccountInfo(name=‘’, token=‘’, secret=‘’) This tells RStudio how to submit your code to shinyapps.io and gives it the permissions to do so. Now, change to the directory where your server.R and ui.R files are at and you can submit your code with: {lang=r,line-numbers=off} ~ deployApp(appName = “myFirstApp”) ~ Make sure that shinyapps is loaded (with library(shinyapps)). If you need a path to your files, put that in the argument to deployApp. The appName argument appears to be necessary, and you want it anyway so you know which app it is on shinyapps.io. If all has gone well, your app will launch and it will open up a browser window linking to it. In my case, the link was. https://bcaffo.shinyapps.io/myFirstApp. You can manage your app in the browswer at shinyapps.io. Now when you go to shinyapps.io and click on Applications/All, or Applicatons/Running then you should see your app. Example app listing at shinyapps.io From here you can start, stop and delete your app. You can also do that in your R console, with the shinapps tools. I would recommend using the web browswer as it’s a little easier, but if you get to the point where you’re writing a lot of apps, you probably want to learn the console commands. 2.16 talk about shiny server later It is important to dinstiguish between a Shiny applications (app) and a Shiny server. A Shiny server is required to host a shiny app for the world. Otherwise, only those who have have shiny installed and have access to your code could run your web application, which in some cases defeats the purpose of making a web application in the first place. In this book, we won’t cover creating a shiny server, as that requires understanding a little linux server administration. Instead, we’ll run our apps locally and use RStudio’s service for hosting shiny apps (their servers) on a platform called shinyapps.io. RStudio does the server work for your so that all you need to worry about is building your app. Shinyapps.io is free up to a point in that you can only run 5 apps for a certain amount of time per month. This will be fine for our purposes, but if you’re really going to get into making Shiny apps, you’ll have to spring for a paid plan or run your own server. "],
["leaflet.html", "Chapter 3 Leaflet", " Chapter 3 Leaflet Watch this video before beginning. "],
["interactive-graphics.html", "Chapter 4 Interactive Graphics", " Chapter 4 Interactive Graphics Watch this video before beginning. "],
["packages.html", "Chapter 5 Packages", " Chapter 5 Packages Watch this video before beginning. "],
["objects.html", "Chapter 6 Objects", " Chapter 6 Objects Watch this video before beginning. "],
["swirl.html", "Chapter 7 Swirl", " Chapter 7 Swirl Watch this video before beginning. "]
]
